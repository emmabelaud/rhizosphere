---
title: "fauna_habitat_data"
format:
  html:
    embed-resources: true

execute: 
  warning: false
  message: false
---

## Generating data on habitat use and availability for observed fauna

This script quantifies habitat selection by soil invertebrates using spatially explicit environmental data. For each invertebrate detection (defined as the centroid of the bounding box), values of distance-based habitat variables are extracted from raster layers, representing observed habitat use.

To characterise habitat availability, a use–availability framework is implemented at the level of individual detections. For each observed detection, 50 random locations are generated within the spatial extent of the corresponding image. Environmental variables are extracted at these random locations, and the mean and standard deviation of each variable are computed. These summary statistics are then associated with the corresponding detection as estimates of expected (i.e., available) habitat conditions.

The resulting dataset therefore links each fauna detection to both observed environmental conditions and detection-specific expected habitat metrics, allowing variability in habitat availability to be explicitly accounted for in subsequent analyses.

```{r}
library(terra)
library(dplyr)
library(stringr)

# ===============================
# Parameters
# ===============================

output_file <- "../data/distance_habitat_data.csv"
tif_dir     <- "/media/ebelaud/INTENSO/output_raster"

selected_vars <- c(
  "distance_root_growth",
  "distance_root_mature"
)

n_rand <- 50

# Input data

tif_files <- list.files(
  path = tif_dir,
  pattern = "\\.tif$",
  full.names = TRUE
)

image_names <- unique(
  str_extract(
    basename(tif_files),
    "^[^_]+_[^_]+_[^_]+_[^_]+_[^_]+"
  )
)

if (file.exists(output_file)) {
  images_done <- unique(read.csv(output_file)$image_name)
} else {
  images_done <- character(0)
}

image_names_to_process <- setdiff(image_names, images_done)

loc_data <- read.csv(
  "../data/fauna_data.csv",
  na.strings = c("", "NA")
) %>%
  filter(!is.na(Predicted.class)) %>%
  mutate(
    x = (xmin + xmax) / 2,
    y = (ymin + ymax) / 2
  ) %>%
  select(image_name, date, scanner, Predicted.class, x, y) %>%
  filter(!Predicted.class %in% c("root", "SOM"))

# Result containers

observed_list <- list()
expected_list <- list()
failed_images <- character(0)

# Main loop

pb <- txtProgressBar(
  min = 0,
  max = length(image_names_to_process),
  style = 3
)

for (i in seq_along(image_names_to_process)) {

  image_name <- image_names_to_process[i]
  setTxtProgressBar(pb, i)
 tryCatch({
   
  # --- Raster selection
  env_files <- tif_files[
    str_detect(basename(tif_files), paste0("^", image_name, "_")) &
    str_detect(basename(tif_files), paste(selected_vars, collapse = "|"))
  ]

  if (length(env_files) == 0) return(NULL)

  env_rasters <- rast(env_files)
  names(env_rasters) <- basename(env_files) |>
    str_remove(paste0("^", image_name, "_")) |>
    str_remove("\\.tif$")

  # --- Occurrences for this image
  loc_img <- loc_data %>%
    filter(image_name == !!image_name)

  if (nrow(loc_img) == 0) return(NULL)

  n_rows <- nrow(env_rasters)
  loc_img <- loc_img %>%
    mutate(y = n_rows - y + 1)

  n_occ <- nrow(loc_img)

# Observed habitat use

  obs_vals <- terra::extract(
    env_rasters,
    loc_img[, c("x", "y")]
  )

  observed_list[[image_name]] <- bind_cols(
    loc_img,
    obs_vals
  )

# Expected habitat availability
  rand_pts <- spatSample(
    env_rasters,
    size = n_occ * n_rand,
    method = "random",
    xy = TRUE
  )

  rand_vals <- terra::extract(
    env_rasters,
    rand_pts[, c("x", "y")]
  )

  rand_vals$occ_id <- rep(seq_len(n_occ), each = n_rand)

  expected_stats <- rand_vals %>%
    select(-ID) %>%
    group_by(occ_id) %>%
    summarise(
      across(
        everything(),
        list(
          mean = ~mean(.x, na.rm = TRUE),
          sd   = ~sd(.x, na.rm = TRUE)
        )
      ),
      .groups = "drop"
    )

  expected_list[[image_name]] <- bind_cols(
    loc_img,
    expected_stats %>% select(-occ_id)
  )
 }, error = function(e) {
    failed_images <<- c(failed_images, image_name)
    message(
      "Image ignorée : ", image_name, "\n",
      "    Raison : ", e$message
    )

    return(NULL)
  })
}

close(pb)

# Merge & export

observed_table <- bind_rows(observed_list) %>%
  rename_with(~ paste0(.x, "_obs"), starts_with("distance"))

availability_table <- bind_rows(expected_list) %>%
  rename_with(~ paste0(.x, "_exp"), starts_with("distance"))

final_table <- observed_table %>%
  left_join(
    availability_table,
    by = c("image_name", "date", "scanner", "Predicted.class", "x", "y")
  )

write.csv(final_table, output_file, row.names = FALSE)
writeLines(failed_images, "../data/failed_images.txt")
```

Consistency check: processed images vs reference image bank

```{r}
# Load the reference list of images expected to be processed
# (one image per line, with file extension)
image_bank <- readLines("../output/image_bank.txt")

# Remove the .png extension to match the 'image_name' format
# used throughout the processing pipeline
image_bank <- tools::file_path_sans_ext(image_bank)

# Extract the list of unique images actually present in the final dataset
images_csv <- unique(final_table$image_name)

# Images expected but missing

# Identify images listed in image_bank but absent from the CSV output
missing_in_csv <- setdiff(image_bank, images_csv)

# Number of missing images
length(missing_in_csv)

# Names of missing images (likely skipped due to processing errors)
missing_in_csv


# Unexpected images
# Identify images present in the CSV output but not listed in image_bank
unexpected_in_csv <- setdiff(images_csv, image_bank)

# Number of unexpected images
length(unexpected_in_csv)

# Names of unexpected images (potential upstream filtering or naming issue)
unexpected_in_csv

```

```{r}
df_a <- read.csv("file_a.csv")
df_b <- read.csv("file_b.csv")

```
