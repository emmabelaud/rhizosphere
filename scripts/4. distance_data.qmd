---
title: "fauna_habitat_data"
format:
  html:
    embed-resources: true

execute: 
  warning: false
  message: false
---

## Generating data on habitat use and availability for observed fauna

This script quantifies root habitat selection by soil invertebrates. For each invertebrate detection (defined as the centroid of the bounding box), values of distance-based habitat variables are extracted from raster layers, representing observed habitat use.

To characterise habitat availability, a use–availability framework is implemented at the level of individual detections. For each observed detection, 50 random locations are generated within the spatial extent of the corresponding image. Environmental variables are extracted at these random locations, and the mean and standard deviation of each variable are computed. These summary statistics are then associated with the corresponding detection as estimates of expected (i.e., available) habitat conditions.

The resulting dataset therefore links each fauna detection to both observed environmental conditions and detection-specific expected habitat metrics, allowing variability in habitat availability to be explicitly accounted for in subsequent analyses.

```{r}
library(terra)
library(dplyr)
library(stringr)

# ===============================
# Parameters
# ===============================

output_file <- "../output/distance_habitat_data.csv"
tif_dir     <- "/media/ebelaud/INTENSO1/output_raster"

selected_vars <- c(
  "distance_root_growth",
  "distance_root_mature"
)

n_rand <- 50

# Input data

tif_files <- list.files(
  path = tif_dir,
  pattern = "\\.tif$",
  full.names = TRUE
)

image_names <- unique(
  str_extract(
    basename(tif_files),
    "^[^_]+_[^_]+_[^_]+_[^_]+_[^_]+"
  )
)

if (file.exists(output_file)) {
  images_done <- unique(read.csv(output_file)$image_name)
} else {
  images_done <- character(0)
}

image_names_to_process <- setdiff(image_names, images_done)

loc_data <- read.csv(
  "../data/fauna_data.csv",
  na.strings = c("", "NA", "background")
) %>%
  filter(!is.na(Predicted.class)) %>%
  mutate(
    x = (xmin + xmax) / 2,
    y = (ymin + ymax) / 2
  ) %>%
  select(image_name, date, scanner, Predicted.class, x, y) %>%
  filter(!Predicted.class %in% c("root", "SOM"))

# Result containers

observed_list <- list()
expected_list <- list()
failed_images <- character(0)

# Main loop

pb <- txtProgressBar(
  min = 0,
  max = length(image_names_to_process),
  style = 3
)

for (i in seq_along(image_names_to_process)) {

  image_name <- image_names_to_process[i]
  setTxtProgressBar(pb, i)
 tryCatch({
   
  # --- Raster selection
  env_files <- tif_files[
    str_detect(basename(tif_files), paste0("^", image_name, "_")) &
    str_detect(basename(tif_files), paste(selected_vars, collapse = "|"))
  ]

  if (length(env_files) == 0) {
      message(" No files found for ", image_name)
      next 
    }

  env_rasters <- rast(env_files)
  names(env_rasters) <- basename(env_files) |>
    str_remove(paste0("^", image_name, "_")) |>
    str_remove("\\.tif$")

  # --- Occurrences for this image
  loc_img <- loc_data %>%
    filter(image_name == !!image_name)

    if (nrow(loc_img) == 0) {
      message(" No invertebrates occurrences found for ", image_name)
      next 
    }

  n_rows <- nrow(env_rasters)
  loc_img <- loc_img %>%
    mutate(y = n_rows - y + 1)

  n_occ <- nrow(loc_img)

# Observed habitat use

  obs_vals <- terra::extract(
    env_rasters,
    loc_img[, c("x", "y")]
  )

  observed_list[[image_name]] <- bind_cols(
    loc_img,
    obs_vals
  )

# Expected habitat availability
  rand_pts <- spatSample(
    env_rasters,
    size = n_occ * n_rand,
    method = "random",
    xy = TRUE
  )

  rand_vals <- terra::extract(
    env_rasters,
    rand_pts[, c("x", "y")]
  )

  rand_vals$occ_id <- rep(seq_len(n_occ), each = n_rand)

  expected_stats <- rand_vals %>%
    select(-ID) %>%
    group_by(occ_id) %>%
    summarise(
      across(
        everything(),
        list(
          mean = ~mean(.x, na.rm = TRUE),
          sd   = ~sd(.x, na.rm = TRUE)
        )
      ),
      .groups = "drop"
    )

  expected_list[[image_name]] <- bind_cols(
    loc_img,
    expected_stats %>% select(-occ_id)
  )
 }, error = function(e) {
    failed_images <<- c(failed_images, image_name)
    message(
      "Image ignorée : ", image_name, "\n",
      "    Raison : ", e$message
    )

    return(NULL)
  })
}

close(pb)

# Merge & export

if (length(observed_list) > 0) {
  observed_table <- bind_rows(observed_list) %>%
    rename_with(
      .fn = ~ paste0(.x, "_obs"), 
      .cols = any_of(names(.)[grepl("^distance", names(.))])
    )
} else {
  observed_table <- NULL
  message("Warning: observed_list is empty. No data to process.")
}

if (length(expected_list) > 0) {
  availability_table <- bind_rows(expected_list) %>%
    rename_with(
      .fn = ~ paste0(.x, "_exp"), 
      .cols = any_of(names(.)[grepl("^distance", names(.))])
    )
} else {
  availability_table <- NULL
  message("Warning: observed_list is empty. No data to process.")
}

if (!is.null(observed_table) && !is.null(availability_table)) {
final_table <- observed_table %>%
  left_join(
    availability_table,
    by = c("image_name", "date", "scanner", "Predicted.class", "x", "y")
  )

write.csv(final_table, output_file, row.names = FALSE)
writeLines(failed_images, "../data/failed_images.txt")
}
```
