---
title: "habitat_data_cleaning"
format: html
editor: visual
---

## Habitat data cleaning

### Import

```{r}
if (!dir.exists("../output")) {
  dir.create("../output")
}

library(tidyverse)
library(data.table)

habitat_data_raw <- read.csv("../data/distance_habitat_data.csv") 
habitat_data <- habitat_data_raw %>% 
  dplyr::select(-ID) %>%  
  drop_na()
```

### Position metadata

```{r}
habitat_data <- habitat_data %>%   
  mutate(position = as.factor(substr(scanner, 4, 4)),     
         depth = as.factor(substr(scanner, 5, 6)),     
         orientation = as.factor(substr(scanner, 8, 8)))
```

### Environmental data

Soil temperature et humidity, and daily amplitude calculation

```{r}
probe_data_raw <- read.csv("../data/Diams_AF1W_soil.csv") 
probe_data <- probe_data_raw %>%
  mutate(date = as.POSIXct(date, format = "%Y-%m-%d %H:%M:%S"), 
         depth=as.factor(depth), 
         position=as.factor(position),
         hum = hum_soil, 
         temp = temp_soil) 


dt <- as.data.table(probe_data)
setorder(dt, depth, position, date)

dt[, temp_soil_amplitude := frollapply(temp_soil, 96, max, align = "right") -
                            frollapply(temp_soil, 96, min, align = "right"),
   by = .(depth, position)]

dt[, hum_soil_amplitude := frollapply(hum_soil, 96, max, align = "right") -
                           frollapply(hum_soil, 96, min, align = "right"),
   by = .(depth, position)]

probe_data_processed <- as.data.frame(dt)

habitat_data <- habitat_data %>%
  mutate(data_init = date,
    date = floor_date(ymd_hms(date), unit = "hour"),
    date = update(date, minute = 0, second = 0)) %>%
  left_join(probe_data_processed %>% 
      drop_na() %>% mutate(depth = as.factor(depth)) %>%
      select(date, depth, position, hum, temp, temp_soil_amplitude, hum_soil_amplitude),by = c("date", "depth", "position"))
```

### Roots data

Calculation of root indices

```{r}
#image resolution
dpi <- 1200 
pixels_per_cm <- dpi / 2.54 

root_density_raw <- read.csv("../data/root_pixels_count.csv")  
root_density_raw <- root_density_raw %>%
  mutate(image_name = sub("\\.png$", "", root_density_raw$file)) %>%  
  separate(file, into = c("bloc", "position", "orientation","year","month", "day", "hour", "minute", "fileextension1"), 
           sep = "_|\\.|H|M.| |-", remove = FALSE)%>%
  mutate(scanner= as.factor(paste(position, orientation, sep = "_")),
         depth = as.factor(substr(scanner, 2, 3)),
         position = as.factor(substr(scanner, 1, 1)),
         orientation = as.factor(substr(scanner, 5, 5)))

duplicate_date <- root_density_raw %>%
  group_by(scanner, year, month, day, hour) %>%
  reframe(has_00 = any(minute == "00")) %>% ungroup()

root_density_raw <- root_density_raw %>%
  left_join(duplicate_date, 
            by = c("scanner","year","month","day","hour")) %>%
  mutate(minute = if_else(minute == "01" & !has_00, "00", minute),
    date = ymd_hm(paste(year, month, day, hour, minute))
  ) %>%select(-has_00)
# Some timestamps are recorded at minute = 1 instead of minute = 0.In some cases both exist, in others only minute = 1 exists. We want to correct minute = 1 to 0 only if there is no existing row at minute = 0.

root_density <- root_density_raw %>%
  filter(minute == "00", hour %in% c("00", "06", "12", "18"))%>%
  filter(date> "2024-03-01 00:00:00")


root_density <- root_density %>%
  arrange(depth, position, orientation, date) %>%  
  group_by(depth, position, orientation,) %>%
  mutate(lag_days = 9,
         date_target = date - days(9),
         date_target_24h = date - days(1)) %>%
  ungroup() %>%
  left_join(root_density %>% 
              select(depth, position, orientation, date, root_pixels_count) %>%
              rename(date_target = date,
                     root_pixels_count_lag = root_pixels_count),
            by = c("depth", "position", "orientation", "date_target")) %>%
  left_join(root_density %>% 
              select(depth, position, orientation, date, root_pixels_count) %>%
              rename(date_target_24h = date,
                     root_pixels_count_lag_6h = root_pixels_count),
            by = c("depth", "position", "orientation", "date_target_24h")) %>%
  mutate(root_growth_pixel_count = root_pixels_count - root_pixels_count_lag,
         root_growth_pixel_count = case_when(root_growth_pixel_count < 0 ~ 0,
    TRUE ~ root_growth_pixel_count), #when negative pixel count, update to 0
         root_mature_pixel_count = root_pixels_count - root_growth_pixel_count,
         root_growth_pixel_count_6h = root_pixels_count - root_pixels_count_lag_6h) %>%
  mutate(root_cm2_count = root_pixels_count / (pixels_per_cm^2),
         root_growth_cm2_count = root_growth_pixel_count / (pixels_per_cm^2),
         root_mature_cm2_count = root_mature_pixel_count / (pixels_per_cm^2),
         root_growth_cm2_count_24h = (root_growth_pixel_count_6h / (pixels_per_cm^2))/24)%>%
  mutate(root_growth_cm2_count_24h = case_when(
    root_growth_cm2_count_24h < 0 ~ 0,
    TRUE ~ root_growth_cm2_count_24h))


habitat_data <- habitat_data %>%   
  left_join(root_density %>% 
              select(image_name, root_cm2_count, root_growth_cm2_count, root_mature_cm2_count,root_growth_cm2_count_24h), 
            by = c("image_name"))

habitat_data %>%   
  left_join(root_density %>% 
              select(image_name, root_growth_pixel_count, root_mature_pixel_count), 
            by = c("image_name"))%>%
  mutate(root_growth_surface_prop = root_growth_pixel_count/(14032*10200),
          root_mature_surface_prop = root_mature_pixel_count/(14032*10200))#%>%summary()
```

### Root surface proportion calculation

```{r}
surface_prop <- habitat_data %>%   
  left_join(root_density %>% 
              select(image_name, root_cm2_count, root_growth_cm2_count, root_mature_cm2_count,root_growth_cm2_count_24h), 
            by = c("image_name"))
```

### Distance data transformation

Outliers analysis : filter all images concerned

```{r}
# Identify target variables: Select all columns starting with "distance_" 
vars_to_analyze <- habitat_data %>% 
  select(starts_with("distance_")) %>% 
  names()

# Define a function to detect outliers based on the IQR (Interquartile Range) method
# Note: Using a multiplier of 3 (instead of 1.5) identifies "extreme" outliers
identify_outliers_iqr <- function(data, var_name) {
  x <- data[[var_name]]
  
  q1 <- quantile(x, 0.25, na.rm = TRUE)
  q3 <- quantile(x, 0.75, na.rm = TRUE)
  iqr <- q3 - q1
  
  lower_bound <- q1 - 3 * iqr
  upper_bound <- q3 + 3 * iqr
  
  # Return rows where the variable value falls outside these bounds
  data %>%
    filter(get(var_name) < lower_bound | get(var_name) > upper_bound)
}

# Batch processing: Iterate through the variable list to create 
# a named list of dataframes, each containing outliers for a specific variable
outliers_iqr_list <- vars_to_analyze %>%
  set_names() %>%
  map(~identify_outliers_iqr(habitat_data_raw, .x))

# Extract "image_name" from specific SD (Standard Deviation) 
# expectation variables to create a "blacklist" of problematic images
outlier_images_to_filter <- outliers_iqr_list[c("distance_root_growth_sd_exp", "distance_root_mature_sd_exp")] %>%
  bind_rows() %>%           # Combine the outlier dataframes into one
  select(image_name) %>%    # Focus only on the image identifiers
  distinct()                # Remove duplicate image names to ensure a unique list

# Remove any row from the original dataset that belongs to the identified outlier images
habitat_data <- habitat_data %>%
  filter(!image_name %in% outlier_images_to_filter$image_name)
```

Conversion of distance data into cm.

In order to apply the log distribution to the "distances" variables, 0 must be eliminated, so a small offset is applied to all distance values.

```{r}
epsilon <- 1e-6

habitat_data <- habitat_data %>%
  mutate(
    across(
      starts_with("distance_root"),
      ~ {
        x <- .x / pixels_per_cm
        # min-max normalization [-1, 1]
        x_scaled <- (2 * (x - min(x, na.rm = TRUE)) / (max(x, na.rm = TRUE) - min(x, na.rm = TRUE))) - 1
        x_scaled
      }
    )
  )

hist(habitat_data$distance_root_growth_sd_exp)
```

### Fauna data

```{r}
# Creation of an invertebrate abundance variable
habitat_data <- habitat_data %>%
  group_by(image_name) %>%
  mutate(invertebrate_count = n()) %>%
  ungroup()

# Creation of a predator abundance variable
predators_count <- habitat_data %>%
  filter(Predicted.class %in% c("mesostigmata", "pseudoscorpionida", "araneae", "lithobiomorpha", "geophilomorpha")) %>%
  count(image_name, name = "predators_count")

habitat_data <- habitat_data %>%
  left_join(predators_count, by = "image_name") %>%
  mutate(predators_count = replace_na(predators_count, 0))

# Taxon filtering 
clean_taxon <- function(x) {
  case_when(
    x %in% c("pseudosinella", "poduromorpha") ~ "collembola",
    x %in% c("trombidiformes", "mesostigmata") ~ "acari",
    TRUE ~ x
  )
}

relevant_taxa <- habitat_data %>%
  mutate(Predicted.class.levelup = clean_taxon(Predicted.class)) %>%
  count(Predicted.class.levelup) %>%
  filter(n >= 300, !Predicted.class.levelup %in% c("unknown", "multi_taxa")) %>%
  pull(Predicted.class.levelup)

habitat_data_filtered <- habitat_data %>%
  mutate(Predicted.class.levelup = clean_taxon(Predicted.class)) %>%
  filter(Predicted.class.levelup %in% relevant_taxa)
```

### Cleaned data recording

```{r}
write.csv(habitat_data_filtered, "../output/distance_data_cleaned.csv", row.names = FALSE)
```
