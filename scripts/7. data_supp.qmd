---
title: "Questioning the influence of roots: supplementary data"
format:
  html:
    css: css/styles.css  
    embed-resources: true
    code-tools: true
    
execute: 
  warning: false
  message: false
  echo: false
---

```{r}
# libraries
library(tidyverse)
library(mgcv)
library(broom)
library(gratia)
library(lubridate)
library(broom)
library(marginaleffects)
library(kableExtra)
library(DHARMa)
library(piecewiseSEM)
library(lme4)
library(webshot2)

# Global settings
set.seed(123)
if (!dir.exists("../output")) dir.create("../output")

# Ring surface function for density normalization
ring_surface <- function(r, width) {
  pi * ((r + width)^2 - r^2)}
# function to extract models results safely
safe_augment <- function(model, data, prefix) {
  df_new <- augment(model) %>%
    select(starts_with(".")) %>%
    rename_with(~ paste0(prefix, .))
  
  bind_cols(data, df_new)
}
```

```{r}
#| label: data-import
# Data Import & Alignment
habitat_data_raw <- read.csv("../output/distance_data_cleaned.csv") %>%
  mutate(date = parse_date_time(date, orders = c("Y-m-d H:M:S", "Y-m-d"), tz = "UTC"))

target_dates <- tibble(
  period = 1:7, 
  start_date = as.Date(c("2024-03-20", "2024-05-25", "2024-07-15", "2024-09-19", 
                         "2024-12-10", "2025-02-15", "2025-04-20"))
)

habitat_data_long <- habitat_data_raw %>%
  crossing(target_dates) %>%                
  filter(date >= start_date) %>%            
  group_by(date) %>%                         
  slice_max(start_date, n = 1) %>%           
  ungroup() %>%
  mutate(across(c(scanner, depth, period, position,orientation, Predicted.class.levelup, image_name), as.factor)) %>%
  select(scanner, image_name, temp, temp_soil_amplitude, hum, hum_soil_amplitude, invertebrate_count, predators_count, period, depth, position, orientation, Predicted.class.levelup, root_cm2_count,root_growth_cm2_count_24h,
         growth_obs = distance_root_growth_obs, 
         growth_exp = distance_root_growth_mean_exp, 
         growth_sd = distance_root_growth_sd_exp,
         mature_obs = distance_root_mature_obs, 
         mature_exp = distance_root_mature_mean_exp, 
         mature_sd = distance_root_mature_sd_exp) %>%
  pivot_longer(cols = starts_with(c("growth", "mature")), 
               names_to = c("root_type", ".value"), names_sep = "_") %>%
  mutate(z_score = (obs - exp) / sd) %>% 
  # filtering of extreme root density values
  filter(root_cm2_count >= quantile(root_cm2_count, 0.25, na.rm = TRUE) - 1.5 * IQR(root_cm2_count, na.rm = TRUE),root_cm2_count <= quantile(root_cm2_count, 0.25, na.rm = TRUE) + 1.5 * IQR(root_cm2_count, na.rm = TRUE)) %>%
  drop_na()
```

## 1. The rhizosphere effect: attraction and spatial signature

### *Do soil fauna actively select the rhizosphere space ?*

```{r}
habitat_data_long %>%
  ggplot()+
  geom_histogram(aes(x=obs))+
  facet_grid(root_type ~ Predicted.class.levelup, scales = "free")
habitat_data_long %>%
  ggplot()+
  geom_histogram(aes(x=exp))+
  facet_grid(root_type ~ Predicted.class.levelup, scales = "free")
habitat_data_long %>%
  ggplot()+
  geom_histogram(aes(x=z_score))+
  facet_grid(root_type ~ Predicted.class.levelup, scales = "free")
```

### *Defining the rhizosphere width*

```{r}
#| label: riz-extraction
### 1. Data Binning and Geometric Area Correction 
max_dist <- 10
bin_w <- 0.1 #cm

# Calculate the number of animals per distance bin and the available area.
rhizo_decay_data <- habitat_data_long %>%
  # Filter out distances that are too large and biased by edge effects
  filter(obs <= max_dist) %>%
  # Create bins and assign observations to the midpoint of the bin
  mutate(dist_bin = floor(obs / bin_w) * bin_w + bin_w/2) %>%
  group_by(dist_bin, Predicted.class.levelup, root_type) %>%
  summarise(n_animals = n(), .groups = "drop") %>%
  # GEOMETRIC CORRECTION: Calculate the area of the concentric ring (annulus).
  # As distance (r) increases, the sampled area increases proportionally.
  # Area = pi * (R_outer^2 - R_inner^2)
  mutate(area = pi * ((dist_bin + bin_w/2)^2 - (dist_bin - bin_w/2)^2)) %>%
  filter(n_animals >= quantile(n_animals, 0.25, na.rm = TRUE) - 1.5 * IQR(n_animals, na.rm = TRUE),n_animals <= quantile(n_animals, 0.25, na.rm = TRUE) + 1.5 * IQR(n_animals, na.rm = TRUE))

### 2. GAM Fitting and Derivative Analysis
extract_gam_stats <- function(df) {
  # Minimum data threshold to ensure model stability
  if (n_distinct(df$dist_bin) < 5 || sum(df$n_animals) < 10) return(NULL)
  
  # MODEL: Generalized Additive Model (GAM)
  # Family = quasipoisson
  # Offset = log(area): Treats the sampled area as an 'exposure' variable. 
  # This converts the raw count model into a density model (count/area) 
  # without the statistical pitfalls of using ratios directly.
  model <- tryCatch({
    gam(n_animals ~ s(dist_bin, k = 5), 
        offset = log(area), 
        data = df, 
        family = nb())
  }, error = function(e) return(NULL))
  
  if (is.null(model)) return(NULL)
  
  # RHIZOSPHERE IDENTIFICATION 
  # We use the first derivative (slope) of the model to find where 
  # the influence of the root stops (the plateau).
  eval_pts <- data.frame(dist_bin = seq(0.05, 10, length.out = 200))
  derivs <- derivatives(model, data = eval_pts, type = "forward")
  
  # STATISTICAL TIPPING POINT:
  # The RIZ is defined as the distance where the 95% Confidence Interval 
  # of the derivative first includes zero. At this point, the density 
  # slope is no longer significantly different from a horizontal line.
  riz_val <- derivs %>%
    mutate(lower = .derivative - 1.96 * .se,
           upper = .derivative + 1.96 * .se) %>%
    # Filter out the first 0.5cm to avoid noise near the root surface
    filter(dist_bin > 0.5, (lower < 0 & upper > 0) | lower > 0) %>% 
    slice(1) %>% 
    pull(dist_bin)
  
  #MODEL VALIDATION TESTS
  res <- simulateResiduals(model, n = 250, plot = FALSE)
  test_ks <- testUniformity(res, plot = FALSE)$p.value             # Distribution test
  test_disp <- testDispersion(res, plot = FALSE)$p.value # Surdispersion test
  test_out <- testOutliers(res, plot = FALSE)$p.value   # Outliers tests
  
  # RESULTS SUMMARY 
  tibble(
    edf = summary(model)$edf,             # Complexity of the curve (1 = linear)
    p_val = summary(model)$s.pv,          # Significance of the spatial pattern
    dev_expl = summary(model)$dev.expl * 100, # % of variance explained by root distance
    riz_cm = if(length(riz_val) > 0) riz_val else NA_real_, # Distance of influence
    n_total = sum(df$n_animals),           # Total count for the group
    check_ks = test_ks,     # If < 0.05, distribution shape problem
    check_disp = test_disp, # If < 0.05, overdispersion (justifies the quasi-Poisson distribution)
    check_out = test_out   # If < 0.05, too many outliers
  )
}

```

```{r}
# 2. Fonction de prédiction REVISITÉE
get_predictions <- function(df_sub, grid_sub) {
  # Filtre de sécurité
  if (nrow(df_sub) < 5 || sum(df_sub$n_animals) < 10) return(NULL)
  
  # Fit du modèle
  m <- tryCatch({
    gam(n_animals ~ s(dist_bin, k = 5), offset = log(area), 
        data = df_sub, family = nb())
  }, error = function(e) return(NULL))
  
  if (is.null(m)) return(NULL)
  
  # Calcul des prédictions sur la grille fournie
  preds <- predict(m, newdata = grid_sub, type = "response", se.fit = TRUE)
  
  # CONSTRUCTION DU DATAFRAME DE SORTIE
  # On crée un nouveau df avec les vecteurs de même taille (100)
  data.frame(
    Predicted.class.levelup = grid_sub$Predicted.class.levelup,
    root_type = grid_sub$root_type,
    dist_bin = grid_sub$dist_bin,
    fit = as.numeric(preds$fit),
    se = as.numeric(preds$se.fit)
  ) %>%
    mutate(
      upper = fit + (1.96 * se),
      lower = pmax(0, fit - (1.96 * se))
    )
}

# 3. Application (la structure reste la même)
all_preds <- rhizo_decay_data %>%
  group_by(Predicted.class.levelup, root_type) %>%
  group_split() %>%
  map_df(~{
    group_info <- .x[1, c("Predicted.class.levelup", "root_type")]
    grid_sub <- eval_grid %>% 
      filter(Predicted.class.levelup == group_info$Predicted.class.levelup, 
             root_type == group_info$root_type)
    get_predictions(.x, grid_sub)
  })

# 4. Graphique
ggplot() +
  geom_point(data = rhizo_decay_data, 
             aes(x = dist_bin, y = n_animals / area), 
             alpha = 0.3, size = 0.8, color = "grey40") +
  geom_ribbon(data = all_preds, 
              aes(x = dist_bin, ymin = lower, ymax = upper), 
              fill = "steelblue", alpha = 0.2) +
  geom_line(data = all_preds, 
            aes(x = dist_bin, y = fit), 
            color = "steelblue", size = 0.7) +
  facet_grid(Predicted.class.levelup ~ root_type, scales = "free_y") +
  theme_bw() +
  labs(x = "Distance (cm)", y = "Densité (ind/cm²)")
```

## 2. The geometric niche: habitat availability constraint

### *Are fauna close to the root by choice (attraction) or necessity (habitat saturation) ?*

```{r}
# Modeling the gap (Obs - Exp) as a function of root density
mod_delta <- gam(
    (obs - exp) ~ Predicted.class.levelup + root_type +
    s(root_cm2_count,  by = interaction(root_type, Predicted.class.levelup,  drop = TRUE), k=5) + 
    s(period, bs = "re") + 
    s(scanner, bs = "re"),
  data = habitat_data_long, 
  family = scat(),
  method = "REML"
)

# Check model performances
#gam.check(mod_delta, rep = 1000)
plot(DHARMa::simulateResiduals(mod_delta))

# Extract significance for plot annotation
s_tab <- as.data.frame(summary(mod_delta)$s.table) %>%
  tibble::rownames_to_column("smooth") %>%
  filter(grepl("root_cm2_count", smooth)) %>%
  mutate(
    p_label = cut(`p-value`, 
                  breaks = c(-Inf, 0.001, 0.01, 0.05, Inf), 
                  labels = c("***", "**", "*", "ns")),
    group_str = gsub("s\\(root_cm2_count\\):interaction\\(root_type, Predicted.class.levelup, drop = TRUE\\)", "", smooth)
  ) %>%
  separate(group_str, into = c("root_type", "Predicted.class.levelup"), sep = "\\.")

# Augment data for plotting
habitat_delta <- safe_augment(mod_delta, habitat_data_long, "delta")

ggplot(habitat_delta, aes(x = root_cm2_count, y = delta.fitted)) +
  geom_hline(yintercept = 0, 
             color = "black", size = 0.5, alpha = 0.3) +
  # The 95% Confidence Interval Envelope
  geom_ribbon(aes(ymin = delta.fitted - 1.96 * delta.se.fit, 
                  ymax = delta.fitted + 1.96 * delta.se.fit), 
              fill = "#002651", alpha = 0.1) +
  # The Original Fitted Points: Points are colored if they represent active attraction 
  geom_jitter(aes(color = period, shape = paste0(position, depth)), size = 2) +
  #scale_color_gradient2(low = "#b20000", mid = "#FFD93D",high = "white",   midpoint = 0) +
  coord_cartesian(ylim = c(-2, 1))+
  # The Rug Plot (Shows data density on the X-axis)
  geom_rug(alpha = 0.2, color = "black", #sides = "b"
           ) +
  # Significance Annotations
  geom_text(data = s_tab, aes(x = Inf, y = -Inf, label = paste("Significance:", p_label)),hjust = 1.5, vjust = -3, inherit.aes = FALSE, size=2,fontface = "bold") +
  
  facet_grid(root_type  ~ Predicted.class.levelup, scales = "free") +
  # Styling
  labs(x = "Root density scaled", y = "Obs − Exp Fitted Distance (cm)",color = "Index") +
  theme_bw() +
  theme(panel.border = element_rect(color = "grey", fill = NA, linewidth = 0.1),
  panel.grid.minor = element_blank(),
  strip.background = element_rect(fill = "white", color = NA),
  strip.text = element_text(size = 9, face = "bold"),
  axis.title.x = element_text(size = 9),
  title = element_text(size=10))
```
