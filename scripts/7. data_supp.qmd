---
title: "Questioning the influence of roots: supplementary data"
format:
  html:
    css: css/styles.css  
    embed-resources: true
    code-tools: true
    
execute: 
  warning: false
  message: false
  echo: false
---

## Setup and data preparation

```{r}
#| label: setup-env
Sys.setenv(CHROMOTE_CHROME_STARTUP_TIMEOUT = 120)
Sys.setenv(CHROMOTE_CHROME_ARGS = "--no-sandbox --disable-gpu --disable-dev-shm-usage")
# libraries
library(tidyverse)
library(mgcv)
library(broom)
library(gratia)
library(lubridate)
library(broom)
library(marginaleffects)
library(kableExtra)
library(DHARMa)
library(piecewiseSEM)
library(lme4)
library(webshot2)
library(patchwork)

# Global settings
set.seed(123)
if (!dir.exists("../output")) dir.create("../output")

# Ring surface function for density normalization
ring_surface <- function(r, width) {
  pi * ((r + width)^2 - r^2)}
# function to extract models results safely
safe_augment <- function(model, data, prefix) {
  df_new <- augment(model) %>%
    select(starts_with(".")) %>%
    rename_with(~ paste0(prefix, .))
  
  bind_cols(data, df_new)
}
```

```{r}
#| label: data-import
# Data Import & Alignment
habitat_data_raw <- read.csv("../output/distance_data_cleaned.csv") %>%
  mutate(date = parse_date_time(date, orders = c("Y-m-d H:M:S", "Y-m-d"), tz = "UTC"))

target_dates <- tibble(
  period = 1:7, 
  start_date = as.Date(c("2024-03-20", "2024-05-25", "2024-07-15", "2024-09-19", 
                         "2024-12-10", "2025-02-15", "2025-04-20"))
)

habitat_data_long <- habitat_data_raw %>%
  crossing(target_dates) %>%                
  filter(date >= start_date) %>%            
  group_by(date) %>%                         
  slice_max(start_date, n = 1) %>%           
  ungroup() %>%
  mutate(across(c(scanner, depth, period, position,orientation, Predicted.class.levelup, image_name), as.factor)) %>%
  select(scanner, image_name, temp, temp_soil_amplitude, hum, hum_soil_amplitude, invertebrate_count, predators_count, period, depth, position, orientation, Predicted.class.levelup, root_cm2_count,root_growth_cm2_count_24h,
         growth_obs = distance_root_growth_obs, 
         growth_exp = distance_root_growth_mean_exp, 
         growth_sd = distance_root_growth_sd_exp,
         mature_obs = distance_root_mature_obs, 
         mature_exp = distance_root_mature_mean_exp, 
         mature_sd = distance_root_mature_sd_exp) %>%
  pivot_longer(cols = starts_with(c("growth", "mature")), 
               names_to = c("root_type", ".value"), names_sep = "_") %>%
  mutate(z_score = (obs - exp) / sd) %>% 
  # filtering of extreme root density values
  filter(root_cm2_count >= quantile(root_cm2_count, 0.25, na.rm = TRUE) - 1.5 * IQR(root_cm2_count, na.rm = TRUE),root_cm2_count <= quantile(root_cm2_count, 0.25, na.rm = TRUE) + 1.5 * IQR(root_cm2_count, na.rm = TRUE)) %>%
  drop_na()

# Creation of an intra-specific invertebrate abundance variable
habitat_data_long <- habitat_data_long %>%
  group_by(image_name, Predicted.class.levelup, root_type) %>%
  mutate(abundance = sqrt(n())) %>%
  ungroup()
```

## 1. Raw data exploration

```{r}
#| label: summary-table
taxa_summary <- habitat_data_long %>%
  group_by(Taxon = Predicted.class.levelup, root_type) %>%
  summarise(
    `Total occurrences` = n(),
    `Sample images` = n_distinct(image_name),
    `Mean occurrence per image` = round(n() / n_distinct(image_name), 2)
  ) %>% select(-root_type) %>% unique() 

# 3. Create the Kable table
taxa_summary %>%
  kbl(caption = "Table 1: Summary of taxonomic occurrences and sampling effort.",
      booktabs = TRUE, align = "lrrr") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), 
                 position = "left") %>%
  add_header_above(c(" " = 1, "Biological Data" = 1, "Sampling Effort" = 2)) %>%
  footnote(general = paste("Total unique images analyzed: ", n_distinct(habitat_data_long$image_name),"\nTotal scanner units: ", n_distinct(habitat_data_long$scanner), "\nTotal period units: ", n_distinct(habitat_data_long$period)))
```

```{r}
#| label: enhanced-effort-matrix
#| fig-height: 6
#| fig-width: 10


# 1. Define the Period-to-Date Mapping (Reference from your code)
period_labels <- c(
  "1" = "Mar 2024\n(Spring)",
  "2" = "May 2024\n(Spring)",
  "3" = "Jul 2024\n(Summer)",
  "4" = "Sep 2024\n(Autumn)",
  "5" = "Dec 2024\n(Winter)",
  "6" = "Feb 2025\n(Winter)",
  "7" = "Apr 2025\n(Spring)"
)

# 2. Prepare the data
effort_summary <- habitat_data_long %>%
  group_by(scanner, period) %>%
  summarise(n_images = n_distinct(image_name), .groups = "drop") 

# 3. Create the Plot
ggplot(effort_summary, aes(x = period, y = scanner, fill = n_images)) +
  geom_tile(color = "white", linewidth = 1.5, alpha=0.5) +
  # Add the exact count inside the tile for maximum precision
  geom_text(aes(label = n_images), color = "black", size = 3.5) +
  scale_fill_gradient(low = "white", high = "#FA812F", name = "Image count") +
  scale_x_discrete(labels = period_labels) +
  theme_minimal() +
  labs(
    title = "Spatio-temporal sampling effort : \ntotal images analyzed per scanner and period",
    x = "Temporal replicates (sampling period)",
    y = "Spatial replicates (Scanner ID)"
  ) +
  guides(fill="none")+
  theme(
    axis.text.x = element_text(angle = 0, hjust = 0.5),
    panel.grid = element_blank(),
    legend.position = "right")
```

```{r}
#| label: metric-variability
#| fig-height: 10
#| fig-width: 12

metrics_long <- habitat_data_long %>%
  select(scanner, period, z_score, root_cm2_count, abundance) %>%
  pivot_longer(cols = c(z_score, root_cm2_count, abundance), 
               names_to = "metric", values_to = "value")

ggplot(metrics_long, aes(x = period, y = value, fill = period)) +
  geom_boxplot(alpha = 0.6, outliers = F) +
  facet_grid(metric ~ scanner, scales = "free_y") +
  scale_fill_brewer(palette = "Spectral",guide = guide_legend(nrow = 1)) +
  theme_minimal() +
  labs(
    title = "Replicate-level variability of studied metrics",
    subtitle = "Rows: Biological and Environmental metrics | Columns: Spatial replicates (Scanners)",
    x = "Temporal Period",
    y = "Measured Value",
    fill = "Period"
  ) +
  theme(
    strip.text.y = element_text(face = "bold", size = 13),
    strip.text.x = element_text(size = 7),
    axis.text.x = element_blank(), 
    legend.position = "bottom",
    legend.text.position = "left"
  )
```

## 1. The rhizosphere effect: attraction and spatial signature

### *Do soil fauna actively select the rhizosphere space ?*

#### Why use Z-scores instead of simple differences?

To evaluate whether soil fauna actively select the rhizosphere, we must distinguish between biological attraction and spatial chance. We utilized a standardized selection index ($z$-score) calculated as:

$$z = \frac{Observed - Expected}{SD_{expected}}$$

While a simple arithmetic difference ($Observed - Expected$) might seem intuitive, it is statistically flawed for comparing different habitats due to **scaling bias**.

The "randomness" of an animal's position is dictated by the underlying geometry of the habitat. This complexity is captured by the **Integrated Spatial SD** ($SD_{expected}$). If we rely on unnormalized differences, we encounter two major issues:

-   **Scale Sensitivity:** A 1cm deviation is a massive biological signal in a dense, low-SD root system, but merely "statistical noise" in a sparse, high-SD environment.

-   **Heteroscedasticity:** As shown in the "Unnormalized Signal" plot, the variance of the raw difference expands as spatial uncertainty increases. This "fan shape" indicates that the metric's reliability is inconsistent across the dataset.

By dividing the deviation by the $SD_{expected}$, we effectively "flatten" the spatial noise. The $z$-score normalization ensures that the 'attraction' metric is relative to the **local spatial probability**.

```{r}
#| label: fig-normalization-comparison
#| fig-height: 6
#| fig-width: 10


# Raw Difference
p1_sd <- ggplot(habitat_data_long, aes(x = sd, y = obs - exp)) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  geom_point(alpha = 0.05) +
  geom_smooth(color = "darkred") +
  labs(title = "Unnormalized Signal", 
       subtitle = "Variance scales with habitat uncertainty",
       x = "Integrated Spatial SD", y = "Obs - Exp (cm)") +
  theme_bw()

# Z-score
p2_sd <- ggplot(habitat_data_long, aes(x = sd, y = z_score)) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  geom_point(alpha = 0.05) +
  geom_smooth(color = "darkblue") +
  labs(title = "Normalized Signal (Z-score)", 
       subtitle = "Stability across all habitat complexities",
       x = "Integrated Spatial SD", y = "Standardized Selection (Z)") +
  theme_bw()

p1_sd + p2_sd
```

The "Normalized Signal" plot demonstrates that the $z$-score remains stable across the entire range of spatial complexities. This process filters out stochastic noise, ensuring that a high negative $z$-score represents a consistent biological "pull" toward the root, regardless of whether the habitat is simple or complex.

### *Defining the rhizosphere width*

Les résultats semblent mauvais donc à voir si on conserve.

## 2. The geometric niche: habitat availability constraint

### *Are fauna close to the root by choice (attraction) or necessity (habitat saturation) ?*

To isolate **active biological selection** from this **geometric necessity**, we analyzed the $z$-score across a gradient of root density.

In our experimental setup, root density within a specific scanner over a 7-day period is often stable. This creates a statistical challenge: if we model every individual occurrence, we artificially inflate the degrees of freedom for a predictor (root density) that isn't actually varying at that scale. To resolve this and provide a conservative estimate of the "Geometric Niche" effect, we performed a sensitivity analysis by comparing two modeling approaches:

-   **Individual-Level Model:** High resolution, but potentially biased by intra-replicate autocorrelation.
-   **Aggregated-Level Model:** Collapsing data to **Scanner × Period × Taxon x Root type** means. This ensures that each data point represents a unique "habitat density state."

Visualizing the Aggregation Logic The visualization below confirms that aggregation preserves the experimental gradient while "flattening" the overrepresented low-density zones created by individual-level clusters.

```{r}
#| label: fig-aggregation-logic
#| fig-width: 10
#| fig-height: 4

# Aggregation
# We collapse individual observations to representative means per habitat state
habitat_data_reframe <- habitat_data_long %>% 
  group_by(scanner, period, Predicted.class.levelup, root_type) %>% 
  summarise(across(c(z_score, root_cm2_count, abundance), mean), .groups = "drop") 

# Scatter Plot: Comparing raw vs aggregated z-scores
p_agg <- ggplot() +
  geom_point(data = habitat_data_long, aes(x = root_cm2_count, y = z_score), color = "grey", alpha = 0.5) +
  geom_point(data = habitat_data_reframe, aes(x = root_cm2_count, y = z_score), color = "orange")+ 
  labs(title = "A. Z-score distribution according to root density", x = expression(Root~Density~(cm^2)), y = "z-score") +
  theme_bw()

# Density Plot: Comparing the underlying density distribution
p_var <- ggplot() +
  geom_density(data = habitat_data_long, aes(x = root_cm2_count),color = "grey", fill = "grey", alpha = 0.3) +
  geom_density(data = habitat_data_reframe, aes(x = root_cm2_count), color = "orange", linewidth = 1) +
  theme_minimal() + labs(title = "B. Predictor Density Distribution", x = expression(Root~Density~(cm^2)), y="Probability Density")

# Combine plots
p_agg + p_var +  
  plot_annotation(title = "Structural impact of data aggregation",
    subtitle = "Grey: individual observations | Orange: Replicate averages (aggregated)")
```

This "vertical striping" seen in Figure A indicates that many fauna occurence share identical root density values, creating pseudoreplication that can lead to Type I errors (false significance). As shown in Figure B, the aggregation process preserves the overall experimental gradient of root density while smoothing over-represented low-density zones.

Model Sensitivity Analysis We implemented two Generalized Additive Models (GAMs) using the scat() family (scaled $t$-distribution) to account for heavy-tailed residuals often found in ecological count-derived data.

```{r}
#| label: model-performance-summary

# Function to run the standard GAM setup
run_constraint_gam <- function(df, k_val) {
  gam(z_score ~ Predicted.class.levelup + root_type +
      s(root_cm2_count, by = interaction(root_type, Predicted.class.levelup, drop = TRUE), k = k_val) + 
      s(period, bs = "re") + 
      s(scanner, bs = "re"),
    data = df, family = scat(), method = "REML")
}

# Run both models
mod_individual <- run_constraint_gam(habitat_data_long, k_val = 5)
mod_aggregated <- run_constraint_gam(habitat_data_reframe, k_val = 4)

model_perf <- list(Individual = mod_individual, Aggregated = mod_aggregated) %>%
  map_df(~{
    sum_mod <- summary(.x)
    smooth_terms <- as.data.frame(sum_mod$s.table)
    sig_count <- sum(smooth_terms$`p-value` < 0.05)
    
    data.frame(
      AIC = AIC(.x),
      Deviance_Explained = sum_mod$dev.expl * 100,
      R_sq_adj = sum_mod$r.sq,
      Avg_EDF = mean(sum_mod$edf),
      Significant_Terms = paste0(sig_count, " / ", nrow(smooth_terms)),
      N_Total = nobs(.x)
    )
  }, .id = "Approach")

# 2. Render the unified table
model_perf %>%
  kbl(
    caption = "Sensitivity Analysis - Comparison of Individual vs. Aggregated Modeling Approaches.",
    digits = 3,
    booktabs = TRUE,
    col.names = c("Model Approach", "AIC", "Dev. Expl. (%)", "Adj. R²", "Mean EDF", "Significant Smooths", "N")
  ) %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = FALSE) %>%
  row_spec(2, bold = TRUE, background = "#FFF4E5") # Highlight the chosen aggregated approach
```

The individual model identifies 6 out of 8 smooth terms as significant. However, this significance is deceptive; with a deviance explained of only 2.6%, the model has almost no predictive power. The low p-values are likely a mathematical byproduct of the large sample size and high spatial autocorrelation (pseudoreplication). The aggregated model, by collapsing the data to replicate means, eliminate individual-level stochasticity. While the "significance" vanishes (0/8 terms), the deviance explained increases nearly four-fold (9.4%). Furthermore, the Average EDF (Effective Degrees of Freedom) drops from \~3.28 to \~1.66, indicating that the model is no longer trying to "wiggle" through noise, but is instead finding a simpler, more stable (though non-significant) trend.

```{r}
#| label: final-constraint-plot
#| fig-width: 10
#| fig-height: 8

# (Using your existing augmentation logic on the aggregated model)
habitat_delta <- safe_augment(mod_aggregated, habitat_data_reframe, "delta")

p_final <- ggplot(habitat_delta, aes(x = root_cm2_count, y = delta.fitted)) +
  geom_hline(yintercept = 0, color = "black", size = 0.5, alpha = 0.3) +
  geom_ribbon(aes(ymin = delta.fitted - 2 * delta.se.fit, 
                  ymax = delta.fitted + 2 * delta.se.fit), 
              fill = "#002651", alpha = 0.1) +
  geom_point(aes(color = delta.fitted), size = 2, alpha = 0.6) +
  scale_color_gradient2(low = "#b20000", mid = "#FFD93D", high = "grey90", midpoint = 0) +
  facet_grid(root_type ~ Predicted.class.levelup, scales = "free") +
  theme_bw() +
  labs(title = "Final Sensitivity Model: Aggregated Response",
       subtitle = "Negative z-scores (red) indicate active biological attraction persisting through habitat saturation",
       x = "Root Density (cm/cm²)", y = "Fitted Selection Intensity (z-score)")

p_final
```

The aggregated model provides a more conservative and honest estimate of the "Geometric Niche." It demonstrates that, once individual-level noise is removed, there is no evidence for a strong non-linear selection effect across the root density gradient.
